@{关于AndroLua - AndroLua+帮助 {@!
AndroLua是基于LuaJava开发的安卓平台轻量级脚本编程语言工具，既具有Lua简洁优雅的特质，又支持绝大部分安卓API，可以使你在手机上快速编写小型应用。
官方QQ群：236938279
官方QQ2群：621400904

百度贴吧：
http://c.tieba.baidu.com/mo/m?kw=androlua
项目地址：
https://github.com/nirenr/AndroLua_pro
打开链接支持nirenr的工作，一块也可以哦：
https://qr.alipay.com/apt7ujjb4jngmu3z9a

AndroLua使用了以下开源项目部分代码：
- bson,crypt,md5
https://github.com/cloudwu/skynet
- cjson
https://sourceforge.net/projects/cjson/
- zlib
https://github.com/brimworks/lua-zlib
- xml
https://github.com/chukong/quick-cocos2d-x
- luv
https://github.com/luvit/luv
https://github.com/clibs/uv
- zip
https://github.com/brimworks/lua-zip
https://github.com/julienr/libzip-android
- luagl
http://luagl.sourceforge.net/
- luasocket
https://github.com/diegonehab/luasocket
- sensor
https://github.com/ddlee/AndroidLuaActivity
- canvas
由落叶似秋开发
- jni
由nirenr开发}@

@{软件基本操作 - AndroLua+帮助 {@!
工程结构
  init.lua：工程配置文件
  main.lua：工程入口文件
  layout.aly：工程默认布局文件

菜单功能
  三角形-运行：执行当前工程
  左箭头-撤销：撤销输入的内容
  右箭头-重做：恢复撤销的内容

  打开：打开文件，在文件列表长按可删除文件
  最近：显示最近打开过的文件

  文件：
    保存：保存当前文件(Androlua+带有自动保存功能，一般情况下不需要点击此项)
    新建：新建lua代码文件或者aly布局文件，代码文件与布局文件的文件名不可以相同
    编译：把当前文件编译为luac文件，通常用不到

  工程：
    打开：在工程列表打开工程
    打包：将当前工程编译为apk，默认使用debug签名
    新建：新建一个工程
    导出：将当前工程备份为alp文件
    属性：编辑当前工程的属性，如版本、包名、权限等

  代码：
    格式化：重新缩进当前文件使其更加便于阅读
    导入分析：分析当前文件及引用文件需要导入的java类
    查错：检查当前文件是否有语法错误

  转到：
    搜索：搜索指定内容的位置
    转到：按行号跳转
    导航：按函数跳转

  插件：使用安装的插件

  其他：
    布局助手：在编辑器打开aly文件时用于设计布局
    日志：查看程序运行时的日志
    java浏览器：用于查看java类的方法
    帮助：Androlua+自带的帮助
    手册：离线版lua官方手册
    联系作者：加入官方qq群与作者交流
    捐赠：使用支付宝捐赠作者，使软件更好的发展下去}@

@{快速入门 - AndroLua+帮助 {@!
<muktc?>
[["p","AndroLua是一个使用Lua语法编写可以使用安卓API的轻型脚本编程工具，使用它可以快速编写安卓应用。\n第一次打开程序默认创建new.lua，并已经添加了以下代码"],["c","Lua","require \"import\"\nimport \"android.widget.\"\nimport \"android.view.\""],"k",["c","Lua","require \"import\" --导入import模块，该模块集成了很多实用的函数，可以大幅度减轻写代码负担，详细函数说明参考程序帮助。\nimport \"android.widget.*\" --导入Java包，这里导入了android的widget和view两个包。"],"k",["p","导入包后使用类是很容易的，新建类实例和调用Lua的函数一样。\n比如新建一个TextView"],["c","Lua","tv=TextView(activity)"],["p","activity表示当前活动的context。\n同理新建按钮"],["c","Lua","btn=Button(activity)"],["p","给视图设置属性也非常简单"],["c","Lua","btn.text=\"按钮\";\nbtn.backgroundColor=0xff0000ff;"],["p","添加视图事件回调函数"],["c","Lua","btn.onClick=function(v)\n  print(v)\nend"],["p","函数参数v是视图本身。"],"k",["p","安卓的视图需要添加到布局才能显示到活动，一般我们常用LinearLayout"],["c","Lua","layout=LinearLayout(activity)"],["p","用addView添加视图"],["c","Lua","layout.addView(btn)"],["p","最后调用activity的setContentView方法显示内容"],["c","Lua","activity.setContentView(layout)"],["p","这里演示androlua基本用法，通常我们需要新建一个工程来开发，代码的用法是相同的，具体细节请详细阅读后面的内容。"]]
}@

@{与标准lua5.3的不同 - AndroLua+帮助 {@!
打开了部分兼容选项，module，unpack，bit32
添加string.gfind函数，用于递归返回匹配位置
增加tointeger函数，强制将数值转为整数
修改tonumber支持转换Java对象}@

@{参考链接 - AndroLua+帮助 {@!
<muktc?>
[["p","关于lua的语法和Android API请参考以下网页。"],"k",["p","Lua官网：","BOLD"],["link","http://www.lua.org","http://www.lua.org"],["p","Android 中文API：","BOLD"],["link","http://android.toolib.net/reference/packages.html","http://android.toolib.net/reference/packages.html"]]
}@

@{导入模块 - AndroLua+帮助 {@!
<muktc?>
[["c","Lua","require \"import\""],["p","以导入import模块，简化写代码的难度。"],"k",["p","目前程序还内置bmob,bson,canvas,cjson,crypt,ftp,gl,http,import,md5,smtp,socket,sensor,xml,zip,zlib等模块。"],"k",["p","一般模块导入形式"],["c","Lua","local http=require \"http\""],["p","这样导入的是局部变量\n导入import后也可以使用"],["c","Lua","import \"http\""],["p","的形式，导入为全局变量"]]
}@

@{导入包或类 - AndroLua+帮助 {@!
<muktc?>
[["p","在使用Java类之前需要导入相应的包或者类，\n可以用包名.*的形式导入导入包"],["c","Lua","import \"android.widget.*\""],"k",["p","或者用完整的类名导入类"],["c","Lua","import \"android.widget.Button\""],["p","导入内部类"],["c","Lua","import \"android.view.View_OnClickListener\""],["p","或者在导入类后直接使用内部类\nView.OnClickListener\n包名和类名必须用引号包围。"],"k",["p","导入的类为全局变量，你可以使用"],["c","Lua","local Burton=import \"android.widget.Button\""],["p","的形式保存为局部变量，以解决类名冲突问题。"]]
}@

@{创建布局与组件 - AndroLua+帮助 {@!
安卓使用布局与视图管理和显示用户界面。
布局负责管理视图如何显示，如LinearLayout以线性排列视图，FrameLayout则要求自行指定停靠与位置。
视图则显示具体内容，如TextView可以向用户展示文字内容，Button可以响应用户点击事件。

创建一个线性布局
layout=LinearLayout(activity)
创建一个按钮视图
button=Button(activity)
将按钮添加到布局
layout.addView(button)
将刚才的内容设置为活动内容视图
activity.setContentView(layout)

注.activity是当前窗口的Context对象，如果你习惯也可以使用this
button=Button(this)}@

@{使用方法 - AndroLua+帮助 {@!
button.setText("按钮")

getter/setter
Java的getxxx方法没有参数与setxxx方法只有一个参数时可以简写，
button.Text="按钮"
x=button.Text}@

@{使用事件 - AndroLua+帮助 {@!
创建事件处理函数
function click(s)
    print("点击")
    end
把函数添加到事件接口
listener=View.OnClickListener{onClick = click}
把接口注册到组件
button.setOnClickListener(listener)

也可以使用匿名函数
button.setOnClickListener(View.OnClickListener {onClick = function(s)
        print("点击")
        end
    })
    
onxxx事件可以简写
button.onClick=function(v)
    print(v)
    end}@
    
@{回调方法 - AndroLua+帮助 {@!
在活动文件添加以下函数，这些函数可以在活动的特定状态执行。
function main(...)
    --...：newActivity传递过来的参数。
    print("入口函数",...)
    end

function onCreate()
    print("窗口创建")
    end

function onStart()
    print("活动开始")
    end
  
function onResume()
    print("返回程序")
    end

function onPause()
    print("活动暂停")
    end

function onStop()
    print("活动停止")
    end

function onDestroy()
    print("程序已退出")
    end

function onResult(name,...)
  --name：返回的活动名称
  --...：返回的参数
  print("返回活动",name,...)
  end

function onCreateOptionsMenu(menu)
    --menu：选项菜单。
    menu.add("菜单")
    end

function onOptionsItemSelected(item)
    --item：选中的菜单项
    print(item.Title)
    end

function onConfigurationChanged(config)
    --config：配置信息
    print("屏幕方向关闭")
    end
  
function onKeyDown(keycode,event)
    --keycode：键值
    --event：事件
    print("按键按下",keycode)
    end

function onKeyUp(keycode,event)
    --keycode：键值
    --event：事件
    print("按键抬起",keycode)
    end

function onKeyLongPress(keycode,event)
    --keycode：键值
    --event：事件
    print("按键长按",keycode)
    end

function onTouchEvent(event)
    --event：事件
    print("触摸事件",event)
    end}@
    
@{按键与触控 - AndroLua+帮助 {@!
function onKeyDown(code,event)
    print(code event)
    end
function onTouchEvent(event)
    print(event)
    end
支持onKeyDown,onKeyUp,onKeyLongPress,onTouchEvent
函数必须返布尔值}@

@{使用数组 - AndroLua+帮助 {@!
array=float{1,2,3}
或者
array=int[10]
a=array[0]
array[0]=4}@

@{使用线程 - AndroLua+帮助 {@!
需导入import模块，参看thread,timer与task函数说明。
线程中使用独立环境运行，不能使用外部变量与函数，需要使用参数和回调与外部交互。
任务

task(str,args,callback)

str 为任务执行代码，args 为参数，callback 为回调函数，任务返回值将传递到回调方法
线程

t=thread(str,args)

str 为线程中执行的代码，args 为初始传入参数
调用线程中方法
call(t,fn,args)
t 为线程，fn 为方法名称，args 为参数
设置线程变量
set(t,fn,arg)
t 为线程，fn 为变量名称，arg 为变量值
线程调用主线程中方法
call(fn,args)
fn 为方法名称，args 为参数
线程设置主线程变量
set(fn,arg)
fn 为变量名称，arg 为变量值

注. 参数类型为 字符串，数值，Java对象，布尔值与nil
线程要使用quit结束线程。

t=timer(func,delay,period,args)

func 为定时器执行的函数，delay 为定时器延时，period 为定时器间隔，args 为初始化参数
t.Enable=false 暂停定时器
t.Enable=true 启动定时器
t.stop() 停止定时器

注意：定时器函数定义run函数时定时器重复执行run函数，否则重复执行构建时的func函数}@


@{使用布局表 - AndroLua+帮助 {@!
使用布局表须导入android.view与android.widget包。
require "import"
import "android.widget.*"
import "android.view.*"
布局表格式
layout={
    控件类名称,
    id=控件名称,
    属性=值,
    {
        子控件类名称,
        id=控件名称,
        属性=值,
        }
    }
  
例如：
layout={
  LinearLayout,--视图类名称
  id="linear",--视图ID，可以在loadlayout后直接使用
  orientation="vertical",--属性与值
  {
    TextView,--子视图类名称
    text="hello AndroLua+",--属性与值
    layout_width="fill"--布局属性
  },
}
使用loadlayout函数解析布局表生成布局。
activity.setContentView(loadlayout(layout))
也可以简化为：
activity.setContentView(layout)
如果使用单独文件布局(比如有个layout.aly布局文件)也可以简写为：
activity.setContentView("layout")
此时不用导入布局文件。

布局表支持大全部安卓控件属性，
与安卓XML布局文件的不同点：
id表示在Lua中变量的名称，而不是安卓的可以findbyid的数字id。
ImageView的src属性是当前目录图片名称或绝对文件路径图片或网络上的图片，
layout_width与layout_height的值支持fill与wrap简写，
onClick值为lua函数或java onClick接口或他们的全局变量名称，
背景background支持背景图片，背景色与LuaDrawable自绘制背景，背景图片参数为是当前目录图片名称或绝对文件路径图片或网络上的图片，颜色同backgroundColor，自绘制背景参数为绘制函数或绘制函数的全局变量名称，
控件背景色使用backgroundColor设置，值为"十六进制颜色值"。
尺寸单位支持 px，dp，sp，in，mm，%w，%h。
其他参考loadlayout与loadbitmap}@

@{2D绘图 - AndroLua+帮助 {@!
require "import"
import "android.app.*"
import "android.os.*"
import "android.widget.*"
import "android.view.*"
import "android.graphics.*"
activity.setTitle('AndroLua')

paint=Paint()
paint.setARGB(100,0,250,0)
paint.setStrokeWidth(20)
paint.setTextSize(28)

sureface = SurfaceView(activity);
callback=SurfaceHolder_Callback{
    surfaceChanged=function(holder,format,width,height)
        end,
    surfaceCreated=function(holder)
        ca=holder.lockCanvas()
        if (ca~=nil) then
            ca.drawRGB(0,79,90);
            ca.drawRect(0,0,200,300,paint)
            end
        holder.unlockCanvasAndPost(ca)
        end,
    surfaceDestroyed=function(holder)
        end
    }
holder=sureface.getHolder()
holder.addCallback(callback)
activity.setContentView(sureface)}@

@{Lua类型与Java类型 - AndroLua+帮助 {@!
在大多数情况下androlua可以很好的处理Lua与Java类型之间的自动转换，但是Java的数值类型有多种(double,float,long,int,short,byte)，而Lua只有number，在必要的情况下可以使用类型的强制转换。
i=int(10)
i就是一个Java的int类型数据
d=double(10)
d是一个Java的double类型
在调用Java方法时androlua可以自动将Lua的table转换成Java的array，Map或interface
Map类型可以像使用Lua表一样简便。
map=HashMap{a=1,b=2}
print(map.a)
map.a=3
取长度运算符#可以获取Java中array，List,Map,Set，String的长度。}@

@{canvas模块 - AndroLua+帮助 {@!
require "import"
import "canvas"
import "android.app.*"
import "android.os.*"
import "android.widget.*"
import "android.view.*"
import "android.graphics.*"
activity.setTitle('AndroLua')

paint=Paint()
paint.setARGB(100,0,250,0)
paint.setStrokeWidth(20)
paint.setTextSize(28)

sureface = SurfaceView(activity);
callback=SurfaceHolder_Callback{
    surfaceChanged=function(holder,format,width,height)
        end,
    surfaceCreated=function(holder)
        ca=canvas.lockCanvas(holder)
        if (ca~=nil) then
            ca:drawRGB(0,79,90)
            ca:drawRect(0,0,200,300,paint)
            end
        canvas.unlockCanvasAndPost(holder,ca)
        end,
    surfaceDestroyed=function(holder)
        end
    }
holder=sureface.getHolder()
holder.addCallback(callback)
activity.setContentView(sureface)}@

@{OpenGL模块 - AndroLua+帮助 {@!
require "import"
import "gl"
import "android.app.*"
import "android.os.*"
import "android.widget.*"
import "android.view.*"
import "android.opengl.*"
activity.setTitle('AndroLua')
--activity.setTheme( android.R.style.Theme_Holo_Light_NoActionBar_Fullscreen)

mTriangleData ={
    0.0, 0.6, 0.0,
    -0.6, 0.0, 0.0,
    0.6, 0.0, 0.0,
    };
mTriangleColor = {
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    };

sr=GLSurfaceView.Renderer{
    onSurfaceCreated=function(gl2, config)
        gl.glDisable(gl.GL_DITHER);
        gl.glHint(gl.GL_PERSPECTIVE_CORRECTION_HINT, gl.GL_FASTEST);
        gl.glClearColor(0, 0, 0, 0);
        gl.glShadeModel(gl.GL_SMOOTH);
        gl.glClearDepth(1.0)
        gl.glEnable(gl.GL_DEPTH_TEST);
        gl.glDepthFunc(gl.GL_LEQUAL);
        end,
    onDrawFrame=function(gl2, config)
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT);
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
        gl.glRotate(0,1,1,1)
        gl.glTranslate(0, 0,0);
        gl.glEnableClientState(gl.GL_VERTEX_ARRAY);
        gl.glEnableClientState(gl.GL_COLOR_ARRAY);
        gl.glVertexPointer( mTriangleData,3);
        gl.glColorPointer(mTriangleColor,4);
        gl.glDrawArrays( gl.GL_TRIANGLE_STRIP , 0, 3);
        gl.glFinish();
        gl.glDisableClientState(gl.GL_VERTEX_ARRAY);
        gl.glDisableClientState(gl.GL_COLOR_ARRAY);
        end,
    onSurfaceChanged= function (gl2, w, h)
        gl.glViewport(0, 0, w, h);
        gl.glLoadIdentity();
        ratio =  w / h;
        gl.glFrustum(-rautio, ratio, -1, 1, 1, 10);
        end
    }

glSurefaceView = GLSurfaceView(activity);
glSurefaceView.setRenderer(sr);
activity.setContentView(glSurefaceView);}@

@{http 同步网络模块 - AndroLua+帮助 {@!
body,cookie,code,headers=http.get(url [,cookie,ua,header])
body,cookie,code,headers=http.post(url ,postdata [,cookie,ua,header])
code,headers=http.download(url [,cookie,ua,ref,header])
body,cookie,code,headers=http.upload(url ,datas ,files [,cookie,ua,header])
参数说明
url 网址
postdata post的字符串或字符串数据组表
datas upload的字符串数据组表
files upload的文件名数据表
cookie 网页要求的cookie
ua 浏览器识别
ref 来源页网址
header http请求头

require "import"
import "http"

--get函数以get请求获取网页，参数为请求的网址与cookie
body,cookie,code,headers=http.get("http://www.androlua.com")

--post函数以post请求获取网页，通常用于提交表单，参数为请求的网址，要发送的内容与cookie
body,cookie,code,headers=http.post("http://androlua.com/Login.Asp?Login=Login&Url=http://androlua.com/bbs/index.asp","name=用户名&pass=密码&ki=1")

--download函数和get函数类似，用于下载文件，参数为请求的网址，保存文件的路径与cookie
http.download("http://androlua.com","/sdcard/a.txt")

--upload用于上传文件，参数是请求的网址，请求内容字符串部分，格式为以key=value形式的表，请求文件部分，格式为key=文件路径的表，最后一个参数为cookie
http.upload("http://androlua.com",{title="标题",msg="内容"},{file1="/sdcard/1.txt",file2="/sdcard/2.txt"})}@

@{import模块 - AndroLua+帮助 {@!
require "import"
import "android.widget.*"
import "android.view.*"
layout={
    LinearLayout,
    orientation="vertical",
    {
        EditText,
        id="edit",
        layout_width="fill"
        },
    {
        Button,
        text="按钮",
        layout_width="fill",
        onClick="click"
        }
    }

function click()
    Toast.makeText(activity, edit.getText().toString(), Toast.LENGTH_SHORT ).show()
    end
activity.setContentView(loadlayout(layout))}@

@{Http 异步网络模块 - AndroLua+帮助 {@!
获取内容 get函数
Http.get(url,cookie,charset,header,callback)
url 网络请求的链接网址
cookie 使用的cookie，也就是服务器的身份识别信息
charset 内容编码
header 请求头
callback 请求完成后执行的函数

除了url和callback其他参数都不是必须的

回调函数接受四个参数值分别是
code 响应代码，2xx表示成功，4xx表示请求错误，5xx表示服务器错误，-1表示出错
content 内容，如果code是-1，则为出错信息
cookie 服务器返回的用户身份识别信息
header 服务器返回的头信息

向服务器发送数据 post函数
Http.post(url,data,cookie,charset,header,callback)
除了增加了一个data外，其他参数和get完全相同
data 向服务器发送的数据

下载文件 download函数
Http.download(url,path,cookie,header,callback)
参数中没有编码参数，其他同get，
path 文件保存路径

需要特别注意一点，只支持同时有127个网络请求，否则会出错

Http其实是对Http.HttpTask的封装，Http.HttpTask使用的更加通用和灵活的形式
参数格式如下
Http.HttpTask( url, String method, cookie, charset, header,  callback) 
所有参数都是必选，没有则传入nil

url 请求的网址
method 请求方法可以是get，post，put，delete等
cookie 身份验证信息
charset 内容编码
header 请求头
callback 回调函数

该函数返回的是一个HttpTask对象，
需要调用execute方法才可以执行，
t=Http.HttpTask(xxx)
t.execute{data}

注意调用的括号是花括号，内容可以是字符串或者byte数组，
使用这个形式可以自己封装异步上传函数}@

@{bmob网络数据库 - AndroLua+帮助 {@!
b=bmob(id,key)
id 用户id，key 应用key。

b:insert(key,data,callback)
新建数据表，key 表名称，data 数据，callback 回调函数。

b:update(key,id,data,callback)
更新数据表，key 表名称id 数据id，data 数据，callback 回调函数。

b:query(key,data,callback)
查询数据表，key 表名称，data 查询规则，callback 回调函数。

b:increment(key,id,k,v,c)
原子计数，key 表名称，id 数据id，k 数据key，v 计数增加量。

b:delete(key,id,callback)
删除数据，key 表名称,id 数据id，callback 回调函数。

b:sign(user,pass,mail,callback)
注册用户，user 用户名，pass 密码，mail 电子邮箱，callback 回调函数。

b:login(user or mail,pass,callback)
登录用户，user 用户名，pass 密码，mail 电子邮箱，callback 回调函数。

b:upload(path,callback)
上传文件，path 文件路径，callback 回调函数。

b:remove(url,callback)
删除文件，url 文件路径，callback 回调函数。

注：
1，查询规则支持表或者json格式，具体用法参考官方api
2，回调函数的第一个参数为状态码，-1 出错，其他状态码参考http状态码，第二个参数为返回内容。}@

@{LuaUtil 辅助库 - AndroLua+帮助 {@!
copyDir(from,to)
复制文件或文件夹，from 源路径，to 目标路径。

zip(from,dir,name)
压缩文件或文件夹，from 源路径，dir 目标文件夹，name zip文件名称。

unZip(from,to)
解压文件，from zip文件路径，to 目标路径。

getFileMD5(path)
获取文件MD5值， path 文件路径。

getFileSha1(path)
获取文件Sha1值， path 文件路径。}@

@{LuaAdapter 适配器 - AndroLua+帮助 {@!
构建方法
adapter=LuaAdapter(activity,data,layout)
构建适配器，activity 当前活动，data 列表数据，layout 列表项目布局。
data格式为{{id=value},{id=value}}格式的数组表。

adapter.add(data)
添加数据，data 为列表项目数据，格式为{id=value}。

adapter.insert(idx,{id=value})
插入数据，idx 为从0计数的插入位置，data 为列表项目数据，格式为{id=value}。

adapter.remove(idx)
删除数据，idx 为从0计数的删除位置。

adapter.clear()
清空数据。

adapter.notifyDataSetChanged()
更新数据。

也可以使用table.insert/table.remove直接对data表操作，table库操作从1开始计数，改操作需要手动更新列表。

在使用LuaAdapter的ListView的onItemClick/onItemLongClick回调函数中，第三个参数为从0开始的项目序号，第四个参数为从1开始的项目序号。}@

@{关于AndroLua打包 - AndroLua+帮助 {@!
新建工程或在脚本目录新建init.lua文件。
写入以下内容，即可将文件夹下所有lua文件打包，main.lua为程序人口。
appname="demo"
appver="1.0"
packagename="com.androlua.demo"
目录下icon.png替换图标，welcome.png替换启动图。
打包使用debug签名。}@

@{部分函数参考 - AndroLua+帮助 {@!
[a]表示参数a可选，(...)表示不定参数。函数调用在只有一个参数且参数为字符串或表时可以省略括号。
AndroLua库函数在import模块，为便于使用都是全局变量。
s 表示string类型，i 表示整数类型，n 表示浮点数或整数类型，t 表示表类型，b 表示布尔类型，o 表示Java对象类型，f为Lua函数。
--表示注释。

each(o)
参数：o 实现Iterable接口的Java对象
返回：用于Lua迭代的闭包
作用：Java集合迭代器

enum(o)
参数：o 实现Enumeration接口的Java对象
返回：用于Lua迭代的闭包
作用：Java集合迭代器

import(s)
参数：s 要载入的包或类的名称
返回：载入的类或模块
作用：载入包或类或Lua模块
import "http" --载入http模块
import "android.widget.*" --载入android.widget包
import "android.widget.Button" --载入android.widget.Button类
import "android.view.View$OnClickListener" --载入android.view.View.OnClickListener内部类

loadlayout(t [,t2])
参数：t 要载入的布局表，t2 保存view的表
返回：布局最外层view
作用：载入布局表，生成view
layout={
    LinearLayout,
    layout_width="fill",
    {
        TextView,
        text="Androlua",
        id="tv"
        }
    }
main={}
activity.setContentView(loadlayout(layout,main))
print(main.tv.getText())

loadbitmap(s)
参数：s 要载入图片的地址，支持相对地址，绝对地址与网址
返回：bitmap对象
作用：载入图片
注意：载入网络图片需要在线程中进行

task(s [,...], f)
参数：s 任务中运行的代码或函数，... 任务传入参数，f 回调函数
返回：无返回值
作用：在异步线程运行Lua代码，执行完毕在主线程调用回调函数
注意：参数类型包括 布尔，数值，字符串，Java对象，不允许Lua对象
function func(a,b)
    require "import"
    print(a,b)
    return a+b
    end
task(func,1,2,print)

thread(s[,...])
参数：s 线程中运行的lua代码或脚本的相对路径(不加扩展名)或函数，... 线程初始化参数
返回：返回线程对象
作用：开启一个线程运行Lua代码
注意：线程需要调用quit方法结束线程
func=[[
a,b=...
function add()
    call("print",a+b)
    end
]]
t=thread(func,1,2)
t.add()

timer(s,i1,i2[,...])
参数：s 定时器运行的代码或函数，i1 前延时，i2 定时器间隔，... 定时器初始化参数
返回：定时器对象
作用：创建定时器重复执行函数
function f(a)
    function run()
        print(a)
        a=a+1
        end
    end

t=timer(f,0,1000,1)
t.Enabled=false--暂停定时器
t.Enabled=true--重新定时器
t.stop()--停止定时器

luajava.bindClass(s)
参数：s class的完整名称，支持基本类型
返回：Java class对象
作用：载入Java class
Button=luajava.bindClass("android.widget.Button")
int=luajava.bindClass("int")

luajava.createProxy(s,t)
参数：s 接口的完整名称，t 接口函数表
返回：Java接口对象
作用：创建Java接口
onclick=luajava.createProxy("android.view.View$OnClickListener",{onClick=function(v)print(v)end})

luajava.createArray(s,t)
参数：s 类的完整名称，支持基本类型，t 要转化为Java数组的表
返回：创建的Java数组对象
作用：创建Java数组
arr=luajava.createArray("int",{1,2,3,4})

luajava.newInstance(s [,...])
参数：s 类的完整名称，... 构建方法的参数
作用：创建Java类的实例
b=luajava.newInstance("android.widget.Button",activity)

luajava.new(o[,...])
参数：o Java类对象，... 参数
返回：类的实例或数组对象或接口对象
作用：创建一个类实例或数组对象或接口对象
注意：当只有一个参数且为表类型时，如果类对象为interface创建接口，为class创建数组，参数为其他情况创建实例
b=luajava.new(Button,activity)
onclick=luajava.new(OnClickListener,{onClick=function(v)print(v)end})
arr=luajava.new(int,{1,2,3})
(示例中假设已载入相关类)

luajava.coding(s [,s2 [, s3]])
参数：s 要转换编码的Lua字符串，s2 字符串的原始编码，s3 字符串的目标编码
返回：转码后的Lua字符串
作用：转换字符串编码
注意：默认进行GBK转UTF8

luajava.clear(o)
参数：o Java对象
返回：无
作用：销毁Java对象
注意：仅用于销毁临时对象

luajava.astable(o)
参数：o Java对象
返回：Lua表
作用：转换Java的Array List或Map为Lua表

luajava.tostring(o)
参数：o Java对象
返回：Lua字符串
作用：相当于 o.toString()}@

@{activity部分API参考 - AndroLua+帮助 {@!
setContentView(layout, env)
设置布局表layout为当前activity的主视图，env是保存视图ID的表，默认是_G
getLuaDir()
返回脚本当前目录
getLuaDir(name)
返回脚本当前目录的子目录
getLuaExtDir()
返回Androlua在SD的工作目录
getLuaExtDir(name)
返回Androlua在SD的工作目录的子目录
getWidth()
返回屏幕宽度
getHeight()
返回屏幕高度，不包括状态栏与导航栏
loadDex(path)
加载当前目录dex或jar，返回DexClassLoader
loadLib(path)
加载当前目录c模块，返回载入后模块的返回值(通常是包含模块函数的包)
registerReceiver(filter)
注册一个广播接收者，当再次调用该方法时将移除上次注册的过滤器
newActivity(req, path, enterAnim, exitAnim, arg)
打开一个新activity，运行路径为path的Lua文件，其他参数为可选，arg为表，接受脚本为变长参数
result{...}
向来源activity返回数据，在源activity的onResult回调
newTask(func[, update], callback)
新建一个Task异步任务，在线程中执行func函数，其他两个参数可选，执行结束回调callback，在任务调用update函数时在UI线程回调该函数
新建的Task在调用execute{}时通过表传入参数，在func以unpack形式接收，执行func可以返回多个值
newThread(func, arg)
新建一个线程，在线程中运行func函数，可以以表的形式传入arg，在func以unpack形式接收
新建的线程调用start()方法运行，线程为含有loop线程，在当前activity结束后自动结束loop
newTimer(func, arg)
新建一个定时器，在线程中运行func函数，可以以表的形式传入arg，在func以unpack形式接收
调用定时器的start(delay, period)开始定时器，stop()停止定时器，Enabled暂停恢复定时器，Period属性改变定时器间隔}@

@{布局表字符串常量 - AndroLua+帮助 {@!
布局表支持属性字符串常量
    -- android:drawingCacheQuality
    auto=0,
    low=1,
    high=2,

    -- android:importantForAccessibility
    auto=0,
    yes=1,
    no=2,

    -- android:layerType
    none=0,
    software=1,
    hardware=2,

    -- android:layoutDirection
    ltr=0,
    rtl=1,
    inherit=2,
    locale=3,

    -- android:scrollbarStyle
    insideOverlay=0x0,
    insideInset=0x01000000,
    outsideOverlay=0x02000000,
    outsideInset=0x03000000,

    -- android:visibility
    visible=0,
    invisible=1,
    gone=2,

    wrap_content=-2,
    fill_parent=-1,
    match_parent=-1,
    wrap=-2,
    fill=-1,
    match=-1,

    -- android:orientation
    vertical=1,
    horizontal= 0,

    -- android:gravity
    axis_clip = 8,
    axis_pull_after = 4,
    axis_pull_before = 2,
    axis_specified = 1,
    axis_x_shift = 0,
    axis_y_shift = 4,
    bottom = 80,
    center = 17,
    center_horizontal = 1,
    center_vertical = 16,
    clip_horizontal = 8,
    clip_vertical = 128,
    display_clip_horizontal = 16777216,
    display_clip_vertical = 268435456,
    --fill = 119,
    fill_horizontal = 7,
    fill_vertical = 112,
    horizontal_gravity_mask = 7,
    left = 3,
    no_gravity = 0,
    relative_horizontal_gravity_mask = 8388615,
    relative_layout_direction = 8388608,
    right = 5,
    start = 8388611,
    top = 48,
    vertical_gravity_mask = 112,
    end = 8388613,

    -- android:textAlignment
    inherit=0,
    gravity=1,
    textStart=2,
    textEnd=3,
    textCenter=4,
    viewStart=5,
    viewEnd=6,
    
    -- android:inputType
    none=0x00000000,
    text=0x00000001,
    textCapCharacters=0x00001001,
    textCapWords=0x00002001,
    textCapSentences=0x00004001,
    textAutoCorrect=0x00008001,
    textAutoComplete=0x00010001,
    textMultiLine=0x00020001,
    textImeMultiLine=0x00040001,
    textNoSuggestions=0x00080001,
    textUri=0x00000011,
    textEmailAddress=0x00000021,
    textEmailSubject=0x00000031,
    textShortMessage=0x00000041,
    textLongMessage=0x00000051,
    textPersonName=0x00000061,
    textPostalAddress=0x00000071,
    textPassword=0x00000081,
    textVisiblePassword=0x00000091,
    textWebEditText=0x000000a1,
    textFilter=0x000000b1,
    textPhonetic=0x000000c1,
    textWebEmailAddress=0x000000d1,
    textWebPassword=0x000000e1,
    number=0x00000002,
    numberSigned=0x00001002,
    numberDecimal=0x00002002,
    numberPassword=0x00000012,
    phone=0x00000003,
    datetime=0x00000004,
    date=0x00000014,
    time=0x00000024,
    
    --android:ellipsize
    end　　  
    start 　　
    middle     
    marquee

相对布局rule
    layout_above=2,
    layout_alignBaseline=4,
    layout_alignBottom=8,
    layout_alignEnd=19,
    layout_alignLeft=5,
    layout_alignParentBottom=12,
    layout_alignParentEnd=21,
    layout_alignParentLeft=9,
    layout_alignParentRight=11,
    layout_alignParentStart=20,
    layout_alignParentTop=10,
    layout_alignRight=7,
    layout_alignStart=18,
    layout_alignTop=6,
    layout_alignWithParentIfMissing=0,
    layout_below=3,
    layout_centerHorizontal=14,
    layout_centerInParent=13,
    layout_centerVertical=15,
    layout_toEndOf=17,
    layout_toLeftOf=0,
    layout_toRightOf=1,
    layout_toStartOf=16
    

尺寸单位
    px=0,
    dp=1,
    sp=2,
    pt=3,
    in=4,
    mm=5}@

@{Intent类介绍{@!
Intent（意图）主要是解决Android应用的各项组件之间的通讯。
Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述.
Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给调用的组件，并完成组件的调用。

因此，Intent在这里起着一个媒体中介的作用
专门提供组件互相调用的相关信息
实现调用者与被调用者之间的解耦。

例如，在一个联系人维护的应用中，当我们在一个联系人列表屏幕(假设对应的Activity为listActivity)上
点击某个联系人后，希望能够跳出此联系人的详细信息屏幕(假设对应的Activity为detailActivity)
为了实现这个目的，listActivity需要构造一个 Intent
这个Intent用于告诉系统，我们要做“查看”动作，此动作对应的查看对象是“某联系人”
然后调用startActivity (Intent intent)，将构造的Intent传入

系统会根据此Intent中的描述到ManiFest中找到满足此Intent要求的Activity，系统会调用找到的 Activity，即为detailActivity，最终传入Intent，detailActivity则会根据此Intent中的描述，执行相应的操作。}@

﻿@{初识AndroLua - Lua教程{@!
AndroLua可以在安卓平台上的用 Lua 开发安卓程序，不仅支持调用Java API，而且支持编写安卓界面程序，还可以将自己写的 Lua 程序打包成apk安装文件安装。Lua 语言的简单使没有任何编程经验的用户也能在短时间内开发出安卓程序，因此，在学习AndroLua之前我们需要先学习 Lua 语言。}@

@{Lua简介 - Lua教程{@!
Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。
Lua 是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组，由Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo所组成并于1993年开发。
那么我们废话不多说来写第一个 Lua 程序吧！}@

@{第一个 Lua 程序 - Lua教程{@!
接下来我们使用 Lua 来输出"Hello World"

print("Hello World")

运行后，会在屏幕上显示 Hello world}@

@{注释 - Lua教程{@!
单行注释:
两个减号是单行注释:

--注释}@

@{标示符 - Lua教程{@!
Lua 表示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字（0到9）。
最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的。
Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符。 Lua 是一个区分大小写的编程语言。因此在 Lua 中 W3c 与 w3c 是两个不同的标示符。以下列出了一些正确的标示符：

mohd         zara      abc     move_name

myname50     _temp     j       a23b9  }@

@{关键词 - Lua教程{@!
以下列出了 Lua 的保留关键字。保留关键字不能作为常量或变量或其他用户自定义标示符：

and      break	     do      else    elseif   end       false
for      function  if      in      local    nil	       not
or	      repeat    return	 then    true     until     while

一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。}@

@{全局变量 - Lua教程{@!
在默认情况下，变量总是认为是全局的。
全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。

print(b)
--nil
b=10
print(b)
--10

如果你想删除一个全局变量，只需要将变量赋值为nil。

b = 2
b = nil
print(b)
--nil

这样变量b就好像从没被使用过一样。换句话说, 当且仅当一个变量不等于nil时，这个变量即存在。}@

@{Lua 数据类型 - Lua教程{@!
Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。
Lua中有8个基本类型分别为：

nil、boolean、number、string、userdata、function、thread和table。

我们可以使用type函数测试给定变量或者值的类型：

print(type("Hello world"))
--string
print(type(10.4*3))
--number
print(type(print))
--function
print(type(type))
--function
print(type(true))
--boolean
print(type(nil))
--nil
print(type(type(X)))
--string}@

@{nil（空） - Lua教程{@!
nil 类型表示一种没有任何有效值，它只有一个值 -- nil，例如打印一个没有赋值的变量，便会输出一个 nil 值：

print(type(a))
--nil

对于全局变量和 table，nil 还有一个"删除"作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉。}@

@{boolean（布尔） - Lua教程{@!
boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是"假"，其他的都为"真"。}@

@{number（数字） - Lua教程{@!
Lua 默认只有一种 number 类型 -- double（双精度）类型（默认类型可以修改 luaconf.h 里的定义），以下几种写法都被看作是 number 类型。}@

@{string（字符串） - Lua教程{@!
字符串由一对双引号或单引号来表示。

string1 = "this is string1"
string2 = 'this is string2'

在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字，字符串连接使用的是 ..如：

print("a" .. 'b')
--ab
print(157 .. 428)
--157428

使用 # 来计算字符串的长度，放在字符串前面，如下实例：

len = "www.androlua.com"
print(#len)
--16}@

@{table（表） - Lua教程{@!
在 Lua 里，table 的创建是通过"构造表达式"来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表:

-- 创建一个空的 table
local tbl1 = {}

-- 直接初始表
local tbl2 = {"apple", "pear", "orange", "grape"}

Lua 中的表（table）其实是一个"关联数组"（associative arrays），数组的索引可以是数字或者是字符串。不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始。table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。}@

@{function（函数） - Lua教程{@!
在 Lua 中，函数是被看作是"第一类值（First-Class Value）"，函数可以存在变量里:

function factorial1(n)
    if n == 0 then
        return 1
    else
        return n * factorial1(n - 1)
    end
end
print(factorial1(5))
factorial2 = factorial1
print(factorial2(5))

function 可以以匿名函数（anonymous function）的方式通过参数传递:

function anonymous(tab, fun)
    for k, v in pairs(tab) do
        print(fun(k, v))
    end
end
tab = { key1 = "val1", key2 = "val2" }
anonymous(tab, function(key, val)
    return key .. " = " .. val
end)}@

@{thread（线程） - Lua教程{@!
在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。
线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。}@

@{userdata（自定义类型） - Lua教程{@!
userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。}@

@{Lua 变量 - Lua教程{@!
变量在使用前，必须在代码中进行声明，即创建该变量。
编译程序执行代码之前编译器需要知道如何给语句变量开辟存储区，用于存储变量的值。
Lua 变量有三种类型：全局变量、局部变量、表中的域。
Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显示声明为局部变量。
局部变量的作用域为从声明位置开始到所在语句块结束。
变量的默认值均为 nil。

a = 5               -- 全局变量
local b = 5         -- 局部变量

function joke()
    c = 5           -- 全局变量
    local d = 6     -- 局部变量
end}@

@{赋值语句 - Lua教程{@!
赋值是改变一个变量的值和改变表域的最基本的方法。

a = "hello" .. "world"
t.n = t.n + 1

Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。

a, b = 10, 2*x       <-->       a=10; b=2*x

遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值：

x, y = y, x                     -- swap 'x' for 'y'
a[i], a[j] = a[j], a[i]         -- swap 'a[i]' for 'a[j]'

当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略：
a. 变量个数 > 值的个数             按变量个数补足nil
b. 变量个数 < 值的个数             多余的值会被忽略
例如：

a, b, c = 0, 1
print(a,b,c)             --> 0   1   nil

a, b = a+1, b+1, b+2     -- value of b+2 is ignored
print(a,b)               --> 1   2

a, b, c = 0
print(a,b,c)             --> 0   nil   nil

上面最后一个例子是一个常见的错误情况，注意：如果要对多个变量赋值必须依次对每个变量赋值。

a, b, c = 0, 0, 0
print(a,b,c)             --> 0   0   0

多值赋值经常用来交换变量，或将函数调用返回给变量：

a, b = f()
f()

返回两个值，第一个赋给a，第二个赋给b。
应该尽可能的使用局部变量，有两个好处：
1. 避免命名冲突。
2. 访问局部变量的速度比全局变量更快。}@

@{索引 - Lua教程{@!
对 table 的索引使用方括号 []。Lua 也提供了 . 操作。

t[i]
t.i                 -- 当索引为字符串类型时的一种简化写法
gettable_event(t,i) -- 采用索引访问本质上是一个类似这样的函数调用

例如：

site = {}
site["key"] = "www.androlua.cn"
print(site["key"])
--www.androlua.cn
print(site.key)
--www.androlua.cn}@

@{Lua 循环 - Lua教程{@!
很多情况下我们需要做一些有规律性的重复操作，因此在程序中就需要重复执行某些语句。
一组被重复执行的语句称之为循环体，能否继续重复，决定循环的终止条件。
循环结构是在一定条件下反复执行某段程序的流程结构，被反复执行的程序被称为循环体。
循环语句是由循环体及循环的终止条件两部分组成的。
Lua 语言提供了以下几种循环处理方式：

while 循环
在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。

for 循环
重复执行指定语句，重复次数可在 for 语句中控制。

Lua repeat...until
重复执行循环，直到 指定的条件为真时为止

循环嵌套
可以在循环内嵌套一个或多个循环语句（while、for、do..while）}@

@{循环控制语句 - Lua教程{@!
循环控制语句用于控制程序的流程， 以实现程序的各种结构方式。
Lua 支持以下循环控制语句：

break 语句
退出当前循环或语句，并开始脚本执行紧接着的语句。}@

@{无限循环 - Lua教程{@!
在循环体中如果条件永远为 true 循环语句就会永远执行下去，以下以 while 循环为例：

while( true )
do
   print("循环将永远执行下去")
end}@

@{Lua 流程控制 - Lua教程{@!
Lua 编程语言流程控制语句通过程序设定一个或多个条件语句来设定。在条件为 true 时执行指定程序代码，在条件为 false 时执行其他指定代码。
控制结构的条件表达式结果可以是任何值，Lua认为false和nil为假，true和非nil为真。
要注意的是Lua中 0 为 true

Lua 提供了以下控制结构语句：
if 语句
if 语句由一个布尔表达式作为条件判断，其后紧跟其他语句组成

if...else 语句
if 语句 可以与 else 语句搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码

if 嵌套语句
你可以在if 或 else if中使用一个或多个 if 或 else if 语句}@

@{Lua 函数 - Lua教程{@!
在Lua中，函数是对语句和表达式进行抽象的主要方法。既可以用来处理一些特殊的工作，也可以用来计算一些值。
Lua 提供了许多的内建函数，你可以很方便的在程序中调用它们，如print()函数可以将传入的参数打印在控制台上。
Lua 函数主要有两种用途：
1.完成指定的任务，这种情况下函数作为调用语句使用；
2.计算并返回值，这种情况下函数作为赋值语句的表达式使用。
以下实例定义了函数 max()，参数为 num1, num2，用于比较两值的大小，并返回最大值：

function max(num1, num2)

   if (num1 > num2) then
      result = num1;
   else
      result = num2;
   end

   return result;
end
-- 调用函数
print("两值比较最大值为 ",max(10,4))
print("两值比较最大值为 ",max(5,6))

Lua 中我们可以将函数作为参数传递给函数，如下实例：

myprint = function(param)
   print("这是打印函数 -   ##",param,"##")
end

function add(num1,num2,functionPrint)
   result = num1 + num2
   -- 调用传递的函数参数
   functionPrint(result)
end
myprint(10)
-- myprint 函数作为参数传递
add(2,5,myprint)

Lua函数中，在return后列出要返回的值得列表即可返回多值，如：

function maximum (a)
    local mi = 1             -- 最大值索引
    local m = a[mi]          -- 最大值
    for i,val in ipairs(a) do
       if val > m then
           mi = i
           m = val
       end
    end
    return m, mi
end

print(maximum({8,10,23,12,5}))

Lua函数可以接受可变数目的参数，和C语言类似在函数参数列表中使用三点（...) 表示函数有可变的参数。
Lua将函数的参数放在一个叫arg的表中，#arg 表示传入参数的个数。
例如，我们计算几个数的平均值：

function average(...)
   result = 0
   local arg={...}
   for i,v in ipairs(arg) do
      result = result + v
   end
   print("总共传入 " .. #arg .. " 个数")
   return result/#arg
end

print("平均值为",average(10,5,3,4,5,6))}@

@{Lua 运算符 - Lua教程{@!
运算符是一个特殊的符号，用于告诉解释器执行特定的数学或逻辑运算。Lua提供了以下几种运算符类型：

算术运算符,关系运算符,逻辑运算符,其他运算符

算术运算符
下表列出了 Lua 语言中的常用算术运算符，设定 A 的值为10，B 的值为 20：

+	加法	A + B 输出结果 30
-	减法	A - B 输出结果 -10
*	乘法	A * B 输出结果 200
/	除法	B / A 输出结果 2
%	取余	B % A 输出结果 0
^	乘幂	A^2   输出结果 100
-	负号	-A    输出结果v -10

关系运算符
下表列出了 Lua 语言中的常用关系运算符，设定 A 的值为10，B 的值为 20：

==	等于，检测两个值是否相等，相等返回 true，
否则返回 false	(A == B) 为 false。
~=	不等于，检测两个值是否相等，相等返回 false，
否则返回 true<	(A ~= B) 为 true。
>	大于，如果左边的值大于右边的值，返回 true，
否则返回 false	(A > B) 为 false。
<	小于，如果左边的值大于右边的值，返回 false，
否则返回 true	(A < B) 为 true。
>=	大于等于，如果左边的值大于等于右边的值，返回 true，
否则返回 false	(A >= B) 返回 false。
<=	小于等于， 如果左边的值小于等于右边的值，返回 true，
否则返回 false	(A <= B) 返回 true。

逻辑运算符
下表列出了 Lua 语言中的常用逻辑运算符，设定 A 的值为 true，B 的值为 false：

and	逻辑与操作符。
如果两边的操作都为 true 则条件为 true。
(A and B) 为 false。
or	逻辑或操作符。
如果两边的操作任一一个为 true 则条件为 true。
(A or B) 为 true。
not	逻辑非操作符。
与逻辑运算结果相反，如果条件为 true，逻辑非为 false。
not(A and B) 为 true。

其他运算符
下表列出了 Lua 语言中的连接运算符与计算表或字符串长度的运算符：

..	连接两个字符串	a..b
#	一元运算符，返回字符串或表的长度。

运算符优先级
从高到低的顺序：

^
not    - (unary)
*      /
+      -
..
<      >      <=     >=     ~=     ==
and
or}@

@{Lua 字符串 - Lua教程{@!
字符串或串(String)是由数字、字母、下划线组成的一串字符。
Lua 语言中字符串可以使用以下三种方式来表示：

单引号间的一串字符。
双引号间的一串字符。
[[和]]间的一串字符。

以上三种方式的字符串实例如下：

string1 = "ALua手册"
print("\"字符串 1 是\"",string1)
--字符串 1 是	ALua手册
string2 = 'androlua.cn'
--字符串 2 是	androlua.cn
print("字符串 2 是",string2)
string3 = [["Lua 教程"]]
print("字符串 3 是",string3)
--字符串 3 是	"Lua 教程"}@

@{Lua 数组 - Lua教程{@!
数组，就是相同数据类型的元素按一定顺序排列的集合，可以是一维数组和多维数组。
Lua 数组的索引键值可以使用整数表示，数组的大小不是固定的。}@

@{一维数组 - Lua教程{@!
一维数组是最简单的数组，其逻辑结构是线性表。一维数组可以用for循环出数组中的元素，如下实例：

array = {"Lua", "Tutorial"}
for i= 0, 2 do
   print(array[i])
end

以上代码执行输出结果为：

nil
Lua
Tutorial

正如你所看到的，我们可以使用整数索引来访问数组元素，如果知道的索引没有值则返回nil。
在 Lua 索引值是以 1 为起始，但你也可以指定 0 开始。}@

@{Lua 迭代器 - Lua教程{@!
迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址

在Lua中迭代器是一种支持指针类型的结构，它可以遍历集合的每一个元素。}@

@{泛型 for 迭代器 - Lua教程{@!
泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。

泛型 for 迭代器提供了集合的 key/value 对，语法格式如下：

for k, v in pairs(t) do
    print(k, v)
end
上面代码中，k, v为变量列表；pair(t)为表达式列表。

查看以下实例:

array = {"Lua", "Tutorial"}

for key,value in ipairs(array)
do
   print(key, value)
end
以上代码执行输出结果为：

Lua
Tutorial

以上实例中我们使用了 Lua 默认提供的迭代函数 ipairs。

下面我们看看范性for的执行过程：

首先，初始化，计算in后面表达式的值，表达式应该返回范性for需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用nil补足，多出部分会被忽略。
第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于for结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。
第三，将迭代函数返回的值赋给变量列表。
第四，如果返回的第一个值为nil循环结束，否则执行循环体。
第五，回到第二步再次调用迭代函数
。在Lua中我们常常使用函数来描述迭代器，每次调用该函数就返回集合的下一个元素。Lua 的迭代器包含以下两种类型：

1，无状态的迭代器
2，多状态的迭代器}@

@{无状态的迭代器 - Lua教程{@!
无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。

每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。

这种无状态迭代器的典型的简单的例子是ipairs，他遍历数组的每一个元素。

以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：

function square(iteratorMaxCount,currentNumber)
   if currentNumber<iteratorMaxCount
   then
      currentNumber = currentNumber+1
   return currentNumber, currentNumber*currentNumber
   end
end

for i,n in square,3,0
do
   print(i,n)
end

以上实例输出结果为：

1
4
9

迭代的状态包括被遍历的表（循环过程中不会改变的状态常量）和当前的索引下标（控制变量），ipairs和迭代函数都很简单，我们在Lua中可以这样实现：

function iter (a, i)
    i = i + 1
    local v = a[i]
    if v then
       return i, v
    end
end

function ipairs (a)
    return iter, a, 0
end

当Lua调用ipairs(a)开始循环时，他获取三个值：迭代函数iter、状态常量a、控制变量初始值0；然后Lua调用iter(a,0)返回1,a[1]（除非a[1]=nil）；第二次迭代调用iter(a,1)返回2,a[2]……直到第一个nil元素。}@

@{多状态的迭代器 - Lua教程{@!
很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到table内，将table作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在table内，所以迭代函数通常不需要第二个参数。

以下实例我们创建了自己的迭代器：

array = {"Lua", "Tutorial"}

function elementIterator (collection)
   local index = 0
   local count = #collection
   -- 闭包函数
   return function ()
      index = index + 1
      if index <= count
      then
         --  返回迭代器的当前元素
         return collection[index]
      end
   end
end

for element in elementIterator(array)
do
   print(element)
end

以上实例输出结果为：

Lua
Tutorial

以上实例中我们可以看到，elementIterator 内使用了闭包函数，实现计算集合大小并输出各个元素。}@

@{Lua 文件 I/O - Lua教程{@!
Lua I/O 库用于读取和处理文件。分为简单模式（和C一样）、完全模式。

简单模式（simple model）拥有一个当前输入文件和一个当前输出文件，并且提供针对这些文件相关的操作。
完全模式（complete model） 使用外部的文件句柄来实现。它以一种面对对象的形式，将所有的文件操作定义为文件句柄的方法
简单模式在做一些简单的文件操作时较为合适。但是在进行一些高级的文件操作的时候，简单模式就显得力不从心。例如同时读取多个文件这样的操作，使用完全模式则较为合适。

打开文件操作语句如下：

file = io.open (filename , mode)
mode 的值有：

"r"	以只读方式打开文件，该文件必须存在。
"w"	打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。
"a"	以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）
"r+"	以可读写方式打开文件，该文件必须存在。
"w+"	打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。
"a+"	与a类似，但此文件可读可写
"b"	二进制模式，如果文件是二进制文件，可以加上b}@

@{I/O 简单模式 - Lua教程{@!
简单模式使用标准的 I/O 或使用一个当前输入文件和一个当前输出文件。

以下为 file.lua 文件代码，操作的文件为test.lua(如果没有你需要创建该文件)，代码如下：

-- 以只读方式打开文件
file = io.open("test.lua", "r")

-- 设置默认输入文件为 test.lua
io.input(file)

-- 输出文件第一行
print(io.read())

-- 关闭打开的文件
io.close(file)

-- 以附加的方式打开只写文件
file = io.open("test.lua", "a")

-- 设置默认输出文件为 test.lua
io.output(file)

-- 在文件最后一行添加 Lua 注释
io.write("--  test.lua 文件末尾注释")

-- 关闭打开的文件
io.close(file)
执行以上代码，你会发现，输出了 test.ua 文件的第一行信息，并在该文件最后一行添加了 lua 的注释。如我这边输出的是：

-- test.lua 文件
在以上实例中我们使用了 io."x" 方法，其中 io.read() 中我们没有带参数，参数可以是下表中的一个：

"*n"	读取一个数字并返回它。例：file.read("*n")
"*a"	从当前位置读取整个文件。例：file.read("*a")
"*l"（默认）	读取下一行，在文件尾 (EOF) 处返回 nil。例：file.read("*l")
number	返回一个指定字符个数的字符串，或在 EOF 时返回 nil。例：file.read(5)
其他的 io 方法有：

io.tmpfile():返回一个临时文件句柄，该文件以更新模式打开，程序结束时自动删除

io.type(file): 检测obj是否一个可用的文件句柄

io.flush(): 向文件写入缓冲中的所有数据

io.lines(optional file name): 返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,但不关闭文件}@

@{I/O 完全模式 - Lua教程{@!
通常我们需要在同一时间处理多个文件。我们需要使用 file:function_name 来代替 io.function_name 方法。以下实例演示了如同同时处理同一个文件:

-- 以只读方式打开文件
file = io.open("test.lua", "r")

-- 输出文件第一行
print(file:read())

-- 关闭打开的文件
file:close()

-- 以附加的方式打开只写文件
file = io.open("test.lua", "a")

-- 在文件最后一行添加 Lua 注释
file:write("--test")

-- 关闭打开的文件
file:close()
执行以上代码，你会发现，输出了 test.ua 文件的第一行信息，并在该文件最后一行添加了 lua 的注释。如我这边输出的是：

-- test.lua 文件
read 的参数与简单模式一致。}@

@{I/O 的其他方法 - Lua教程{@!
file:seek(optional whence, optional offset): 设置和获取当前文件位置,成功则返回最终的文件位置(按字节),失败则返回nil加错误信息。参数 whence 值可以是:

"set": 从文件头开始
"cur": 从当前位置开始[默认]
"end": 从文件尾开始
offset:默认为0
不带参数file:seek()则返回当前位置,file:seek("set")则定位到文件头,file:seek("end")则定位到文件尾并返回文件大小
file:flush(): 向文件写入缓冲中的所有数据

io.lines(optional file name): 打开指定的文件filename为读模式并返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,并自动关闭文件。
若不带参数时io.lines() <=> io.input():lines(); 读取默认输入设备的内容，但结束时不关闭文件,如

for line in io.lines("main.lua") do

　　print(line)

　　end

以下实例使用了 seek 方法，定位到文件倒数第 25 个位置并使用 read 方法的 *a 参数，即从当期位置(倒数第 25 个位置)读取整个文件。

-- 以只读方式打开文件
file = io.open("test.lua", "r")

file:seek("end",-25)
print(file:read("*a"))

-- 关闭打开的文件
file:close()
我这边输出的结果是：

st.lua 文件末尾--test}@

@{Lua 错误处理 - Lua教程{@!
程序运行中错误处理是必要的，在我们进行文件操作，数据转移及web service 调用过程中都会出现不可预期的错误。如果不注重错误信息的处理，就会照成信息泄露，程序无法运行等情况。
任何程序语言中，都需要错误处理。错误类型有：
1，语法错误
2，运行错误}@

@{语法错误 - Lua教程{@!
语法错误通常是由于对程序的组件（如运算符、表达式）使用不当引起的。一个简单的实例如下：
-- test.lua 文件
a == 2
以上代码执行结果为：

lua: test.lua:2: syntax error near '=='

正如你所看到的，以上出现了语法错误，一个 "=" 号跟两个 "=" 号是有区别的。一个 "=" 是赋值表达式两个 "=" 是比较运算。
另外一个实例:

for a= 1,10
   print(a)
end

执行以上程序会出现如下错误：

lua: test2.lua:2: 'do' expected near 'print'

语法错误比程序运行错误更简单，运行错误无法定位具体错误，而语法错误我们可以很快的解决，如以上实例我们只要在for语句下添加 do 即可：

for a= 1,10
do
   print(a)
end}@

@{运行错误 - Lua教程{@!
运行错误是程序可以正常执行，但是会输出报错信息。如下实例由于参数输入错误，程序执行时报错：

function add(a,b)
   return a+b
end

add(10)

当我们编译运行以下代码时，编译是可以成功的，但在运行的时候会产生如下错误：

lua: test2.lua:2: attempt to perform arithmetic on local 'b' (a nil value)
stack traceback:
    test2.lua:2: in function 'add'
    test2.lua:5: in main chunk
    [C]: ?

以下报错信息是由于程序缺少 b 参数引起的。}@

@{错误处理 - Lua教程{@!
我们可以使用两个函数：assert 和 error 来处理错误。实例如下：

local function add(a,b)
   assert(type(a) == "number", "a 不是一个数字")
   assert(type(b) == "number", "b 不是一个数字")
   return a+b
end
add(10)

执行以上程序会出现如下错误：

lua: test.lua:3: b 不是一个数字
stack traceback:
    [C]: in function 'assert'
    test.lua:3: in local 'add'
    test.lua:6: in main chunk
    [C]: in ?

实例中assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出。}@

@{error函数 - Lua教程{@!
语法格式：

error (message [, level])

功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)
通常情况下，error会附加一些错误位置的信息到message头部。
Level参数指示获得错误的位置:
Level=1[默认]：为调用error位置(文件+行号)
Level=2：指出哪个调用error的函数的函数
Level=0:不添加错误位置信息}@

@{pcall 和 xpcall、debug - Lua教程{@!
Lua中处理错误，可以使用函数pcall（protected call）来包装需要执行的代码。
pcall接收一个函数和要传递个后者的参数，并执行，执行结果：有错误、无错误；返回值true或者或false, errorinfo。
语法格式如下

if pcall(function_name, ….) then
-- 没有错误
else
-- 一些错误
end

简单实例：

> =pcall(function(i) print(i) end, 33)
33
true

> =pcall(function(i) print(i) error('error..') end, 33)
33
false        stdin:1: error..
> function f() return false,2 end
> if f() then print '1' else print '0' end
0

pcall以一种"保护模式"来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。
通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。
Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展看（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。
debug库提供了两个通用的错误处理函数:

debug.debug：提供一个Lua提示符，让用户来价差错误的原因
debug.traceback：根据调用桟来构建一个扩展的错误消息

>=xpcall(function(i) print(i) error('error..') end, function() print(debug.traceback()) end, 33) 33 stack traceback: stdin:1: in function [C]: in function 'error' stdin:1: in function [C]: in function 'xpcall' stdin:1: in main chunk [C]: in ? false nil

xpcall 使用实例 2:

function myfunction ()
   n = n/nil
end

function myerrorhandler( err )
   print( "ERROR:", err )
end

status = xpcall( myfunction, myerrorhandler )
print( status)

执行以上程序会出现如下错误：

ERROR:    test2.lua:2: attempt to perform arithmetic on global 'n' (a nil value)
false}@

@{Lua 调试(Debug) - Lua教程{@!
Lua 提供了 debug 库用于提供创建我们自定义调速器的功能。Lua 本身并未有内置的调速器，但很多开发者共享了他们的 Lua 调速器代码。
Lua 中 debug 库包含以下函数：

sethook ([thread,] hook, mask [, count]):

1.debug():
进入一个用户交互模式，运行用户输入的每个字符串。 使用简单的命令以及其它调试设置，用户可以检阅全局变量和局部变量， 改变变量的值，计算一些表达式，等等。
输入一行仅包含 cont 的字符串将结束这个函数， 这样调用者就可以继续向下运行。

2.getfenv(object):
返回对象的环境变量。

3.gethook(optional thread):
返回三个表示线程钩子设置的值： 当前钩子函数，当前钩子掩码，当前钩子计数

4.getinfo ([thread,] f [, what]):
返回关于一个函数信息的表。 你可以直接提供该函数， 也可以用一个数字 f 表示该函数。 数字 f 表示运行在指定线程的调用栈对应层次上的函数： 0 层表示当前函数（getinfo 自身）； 1 层表示调用 getinfo 的函数 （除非是尾调用，这种情况不计入栈）；等等。 如果 f 是一个比活动函数数量还大的数字， getinfo 返回 nil。

5.debug.getlocal ([thread,] f, local):
此函数返回在栈的 f 层处函数的索引为 local 的局部变量 的名字和值。 这个函数不仅用于访问显式定义的局部变量，也包括形参、临时变量等。

6.getmetatable(value):
把给定索引指向的值的元表压入堆栈。如果索引无效，或是这个值没有元表，函数将返回 0 并且不会向栈上压任何东西。

7.getregistry():
返回注册表表，这是一个预定义出来的表， 可以用来保存任何 C 代码想保存的 Lua 值。

8.getupvalue (f, up)
此函数返回函数 f 的第 up 个上值的名字和值。 如果该函数没有那个上值，返回 nil 。
以 '(' （开括号）打头的变量名表示没有名字的变量 （去除了调试信息的代码块）。

10.将一个函数作为钩子函数设入。 字符串 mask 以及数字 count 决定了钩子将在何时调用。 掩码是由下列字符组合成的字符串，每个字符有其含义：
'c': 每当 Lua 调用一个函数时，调用钩子；
'r': 每当 Lua 从一个函数内返回时，调用钩子；
'l': 每当 Lua 进入新的一行时，调用钩子。

11.setlocal ([thread,] level, local, value):
这个函数将 value 赋给 栈上第 level 层函数的第 local 个局部变量。 如果没有那个变量，函数返回 nil 。 如果 level 越界，抛出一个错误。

12.setmetatable (value, table):
将 value 的元表设为 table （可以是 nil）。 返回 value。

13.setupvalue (f, up, value):
这个函数将 value 设为函数 f 的第 up 个上值。 如果函数没有那个上值，返回 nil 否则，返回该上值的名字。

14.traceback ([thread,] [message [, level]]):
如果 message 有，且不是字符串或 nil， 函数不做任何处理直接返回 message。 否则，它返回调用栈的栈回溯信息。 字符串可选项 message 被添加在栈回溯信息的开头。 数字可选项 level 指明从栈的哪一层开始回溯 （默认为 1 ，即调用 traceback 的那里）。

上表列出了我们常用的调试函数，接下来我们可以看些简单的例子：

function myfunction ()
print(debug.traceback("Stack trace"))
print(debug.getinfo(1))
print("Stack trace end")
    return 10
end
myfunction ()
print(debug.getinfo(1))

执行以上代码输出结果为：

Stack trace
stack traceback:
    test2.lua:2: in function 'myfunction'
    test2.lua:8: in main chunk
    [C]: ?
table: 0054C6C8
Stack trace end

在以实例中，我们使用到了 debug 库的 traceback 和 getinfo 函数， getinfo 函数用于返回函数信息的表。 }@

@{调试函数的另一个实例 - Lua教程{@!
我们经常需要调试函数的内的局部变量。我们可以使用 getupvalue 函数来设置这些局部变量。实例如下：

function newCounter ()
  local n = 0
  local k = 0
  return function ()
    k = n
    n = n + 1
    return n
    end
end

counter = newCounter ()
print(counter())
print(counter())

local i = 1

repeat
  name, val = debug.getupvalue(counter, i)
  if name then
    print ("index", i, name, "=", val)
    if(name == "n") then
        debug.setupvalue (counter,2,10)
    end
    i = i + 1
  end -- if
until not name

print(counter())

执行以上代码输出结果为：

1
2
index    1    k    =    1
index    2    n    =    2
11

在以上实例中，计数器在每次调用时都会自增1。实例中我们使用了 getupvalue 函数查看局部变量的当前状态。我们可以设置局部变量为新值。实例中，在设置前 n 的值为 2,使用 setupvalue 函数将其设置为 10。现在我们调用函数，执行后输出为 11 而不是 3。}@

@{调试类型 - Lua教程{@!
1，命令行调试
2，图形界面调试

命令行调试器有：RemDebug、clidebugger、ctrace、xdbLua、LuaInterface - Debugger、Rldb、ModDebug。
图形界调试器有：SciTE、Decoda、ZeroBrane Studio、akdebugger、luaedit。}@

@{Lua 垃圾回收 - Lua教程{@!
Lua 采用了自动内存管理。 这意味着你不用操心新创建的对象需要的内存如何分配出来， 也不用考虑在对象不再被使用后怎样释放它们所占用的内存。
Lua 运行了一个垃圾收集器来收集所有死对象 （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。
Lua 实现了一个增量标记-扫描收集器。 它使用这两个数字来控制垃圾收集循环： 垃圾收集器间歇率和垃圾收集器步进倍率。 这两个数字都使用百分数为单位 （例如：值 100 在内部表示 1 ）。
垃圾收集器间歇率控制着收集器需要在开启新的循环前要等待多久。 增大这个值会减少收集器的积极性。 当这个值比 100 小的时候，收集器在开启新的循环前不会有等待。 设置这个值为 200 就会让收集器等到总内存使用量达到 之前的两倍时才开始新的循环。
垃圾收集器步进倍率控制着收集器运作速度相对于内存分配速度的倍率。 增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度。 不要把这个值设得小于 100 ， 那样的话收集器就工作的太慢了以至于永远都干不完一个循环。 默认值是 200 ，这表示收集器以内存分配的"两倍"速工作。
如果你把步进倍率设为一个非常大的数字 （比你的程序可能用到的字节数还大 10% ）， 收集器的行为就像一个 stop-the-world 收集器。 接着你若把间歇率设为 200 ， 收集器的行为就和过去的 Lua 版本一样了： 每次 Lua 使用的内存翻倍时，就做一次完整的收集。}@

@{垃圾回收器函数 - Lua教程{@!
Lua 提供了以下函数collectgarbage ([opt [, arg]])用来控制自动内存管理:

1， collectgarbage("collect"): 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：
2， collectgarbage("count"): 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。
3， collectgarbage("restart"): 重启垃圾收集器的自动运行。
4， collectgarbage("setpause"): 将 arg 设为收集器的 间歇率 （参见 §2.5）。 返回 间歇率 的前一个值。
5， collectgarbage("setstepmul"): 返回 步进倍率 的前一个值。
6， collectgarbage("step"): 单步运行垃圾收集器。 步长"大小"由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回 true 。
7， collectgarbage("stop"): 停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行。

以下演示了一个简单的垃圾回收实例:

mytable = {"apple", "orange", "banana"}

print(collectgarbage("count"))

mytable = nil

print(collectgarbage("count"))

print(collectgarbage("collect"))

print(collectgarbage("count"))

执行以上程序，输出结果如下(注意内存使用的变化)：

20.9560546875
20.9853515625
0
19.4111328125}@

@{Lua 面向对象 - Lua教程{@!
面向对象编程（Object Oriented Programming，OOP）是一种非常流行的计算机编程架构。
以下几种编程语言都支持面向对象编程：

C++
Java
Objective-C
Smalltalk
C#
Ruby}@

@{面向对象特征 - Lua教程{@!
1， 封装：指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性。
2， 继承：继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能也得以扩展。这有利于减少重复编码，提高软件的开发效率。
3， 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。
4，抽象：抽象(Abstraction)是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。}@

@{Lua 中面向对象 - Lua教程{@!
我们知道，对象由属性和方法组成。LUA中最基本的结构是table，所以需要用table来描述对象的属性。
lua中的function可以用来表示方法。那么LUA中的类可以通过table + function模拟出来。
至于继承，可以通过metetable模拟出来（不推荐用，只模拟最基本的对象大部分时间够用了）。

Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。对象有他们的成员函数，表也有：

Account = {balance = 0}
function Account.withdraw (v)
    Account.balance = Account.balance - v
end

这个定义创建了一个新的函数，并且保存在Account对象的withdraw域内，下面我们可以这样调用：

Account.withdraw(100.00)

一个简单实例
以下简单的类包含了三个属性： area, length 和 breadth，printArea方法用于打印计算结果：

-- Meta class
Rectangle = {area = 0, length = 0, breadth = 0}
-- 派生类的方法 new
function Rectangle:new (o,length,breadth)
  o = o or {}
  setmetatable(o, self)
  self.__index = self
  self.length = length or 0
  self.breadth = breadth or 0
  self.area = length*breadth;
  return o
end
-- 派生类的方法 printArea
function Rectangle:printArea ()
  print("矩形面积为 ",self.area)
end

创建对象
创建对象是位类的实例分配内存的过程。每个类都有属于自己的内存并共享公共数据。
r = Rectangle:new(nil,10,20)

访问属性
我们可以使用点号(.)来访问类的属性：
print(r.length)

访问成员函数
我们可以使用冒号 : 来访问类的成员函数：
r:printArea()
内存在对象初始化时分配。

完整实例

以下我们演示了 Lua 面向对象的完整实例：

-- Meta class
Shape = {area = 0}

-- 基础类方法 new
function Shape:new (o,side)
  o = o or {}
  setmetatable(o, self)
  self.__index = self
  side = side or 0
  self.area = side*side;
  return o
end

-- 基础类方法 printArea
function Shape:printArea ()
  print("面积为 ",self.area)
end

-- 创建对象
myshape = Shape:new(nil,10)

myshape:printArea()

执行以上程序，输出结果为：

面积为     100}@

@{Lua 继承 - Lua教程{@!
继承是指一个对象直接使用另一对象的属性和方法。可用于扩展基础类的属性和方法。
以下演示了一个简单的继承实例：

 -- Meta class
Shape = {area = 0}
-- 基础类方法 new
function Shape:new (o,side)
  o = o or {}
  setmetatable(o, self)
  self.__index = self
  side = side or 0
  self.area = side*side;
  return o
end
-- 基础类方法 printArea
function Shape:printArea ()
  print("面积为 ",self.area)
end

接下来的实例，Square 对象继承了 Shape 类:

Square = Shape:new()
-- Derived class method new
function Square:new (o,side)
  o = o or Shape:new(o,side)
  setmetatable(o, self)
  self.__index = self
  return o
end

完整实例
以下实例我们继承了一个简单的类，来扩展派生类的方法，派生类中保留了继承类的成员变量和方法：

 -- Meta class
Shape = {area = 0}
-- 基础类方法 new
function Shape:new (o,side)
  o = o or {}
  setmetatable(o, self)
  self.__index = self
  side = side or 0
  self.area = side*side;
  return o
end
-- 基础类方法 printArea
function Shape:printArea ()
  print("面积为 ",self.area)
end

-- 创建对象
myshape = Shape:new(nil,10)
myshape:printArea()

Square = Shape:new()
-- 派生类方法 new
function Square:new (o,side)
  o = o or Shape:new(o,side)
  setmetatable(o, self)
  self.__index = self
  return o
end

-- 派生类方法 printArea
function Square:printArea ()
  print("正方形面积为 ",self.area)
end

-- 创建对象
mysquare = Square:new(nil,10)
mysquare:printArea()

Rectangle = Shape:new()
-- 派生类方法 new
function Rectangle:new (o,length,breadth)
  o = o or Shape:new(o)
  setmetatable(o, self)
  self.__index = self
  self.area = length * breadth
  return o
end

-- 派生类方法 printArea
function Rectangle:printArea ()
  print("矩形面积为 ",self.area)
end

-- 创建对象
myrectangle = Rectangle:new(nil,10,20)
myrectangle:printArea()

执行以上代码，输出结果为：

面积为     100
正方形面积为     100
矩形面积为     200}@

@{函数重写 - Lua教程{@!
Lua 中我们可以重写基础类的函数，在派生类中定义自己的实现方式：

-- 派生类方法 printArea
function Square:printArea ()
  print("正方形面积 ",self.area)
end}@

@{类型简介{@!
Lua 存在的数据类型包括:
1.nil
此类型只有一个值 nil。用于表示“空”值。全局变量默认为 nil，删除一个已经赋值的全局变量只需要将其赋值为 nil（对比 JavaScript，赋值 null 并不能完全删除对象的属性，属性还存在，值为 null）

2.boolean
此类型有两个值 true 和 false。在 Lua 中，false 和 nil 都表示条件假，其他值都表示条件真（区别于 C/C++ 等语言的是，0 是真）

3.number
双精浮点数（IEEE 754 标准），Lua 没有整数类型

4.string
你可以保存任意的二进制数据到字符串中（包括 0）。字符串中的字符是不可以改变的（需要改变时，你只能创建一个新的字符串）。获取字符串的长度，可以使用 # 操作符（长度操作符）。例如：print(#”hello”)。字符串可以使用单引号，也可以使用双引号包裹，对于多行的字符串还可以使用 [[ 和 ]] 包裹。字符串中可以使用转义字符，例如 \n \r 等。使用 [[ 和 ]] 包裹的字符串中的转义字符不会被转义

5.userdata
用于保存任意的 C 数据。userdata 只能支持赋值操作和比较测试

6.function
函数是第一类值（first-class value），我们能够像使用其他变量一样的使用函数（函数能够保存在变量中，可以作为参数传递给函数）

7.thread
区别于我们常常说的系统级线程

8.table
被实现为关联数组（associative arrays），可以通过任何值来进行索引（nil 除外）。和全局变量一样，table 中未赋值的域为 nil，删除一个域只需要将其赋值为 nil（实际上，全局变量就是被放置在一个 table 中）

type 函数用于返回值的类型：
print(type("Hello World")) --> string
print(type(10.4*3))        --> number
print(type(print))         --> function
print(type(type(X)))       --> string}@

@{Table(数组){@!
table是lua唯一的数据结构。
table是lua中最重要的数据类型。 
table类似于 python 中的字典。
table只能通过构造式来创建。其他语言提供的其他数据结构如array、list等等，lua都是通过table来实现的。
table非常实用，可以用在不同的情景下。最常用的方式就是把table当成其他语言的数组。

实例1:
mytable = {}
for index = 1, 100 do
    mytable[index] = math.random(1,1000)
end

说明：
1.数组不必事先定义大小，可动态增长。
2.创建包含100个元素的table，每个元素随机赋1-1000之间的值。
3.可以通过mytable[x]访问任意元素，x表示索引。
4.索引从1开始。

实例2:
tab = { a = 10, b = 20, c = 30, d = 'www.jb51.net' }
print(tab["a"]) 

说明：
1.table 中的每项要求是 key = value 的形式。
2.key 只能是字符串， 这里的 a, b, c, d 都是字符串，但是不能加上引号。
3.通过 key 来访问 table 的值，这时候， a 必须加上引号。

实例3:
tab = { 10, s = 'abc', 11, 12, 13 } 
print(tab[1]) = 10
print(tab[2]) = 11
print(tab[3]) = 12
print(tab[4]) = 13
说明：
1.数标从1开始。
2.省略key，会自动以1开始编号，并跳过设置过的key。}@

@{比较操作符{@!
--Lua 支持下列比较操作符：

==: 等于
~=: 不等于
<: 小于
>: 大于
<=: 小于等于
>=: 大于等于
这些操作的结果不是 false就是 true。}@
